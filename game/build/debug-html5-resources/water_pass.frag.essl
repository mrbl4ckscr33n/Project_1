#version 100
#extension GL_EXT_shader_texture_lod : require
precision mediump float;
precision highp int;

uniform highp sampler2D gbufferD;
uniform highp vec3 eye;
uniform highp vec3 eyeLook;
uniform highp vec2 cameraProj;
uniform highp float time;
uniform highp sampler2D sdetail;
uniform highp sampler2D sbase;
uniform highp sampler2D tex;
uniform highp vec3 ld;
uniform highp sampler2D sfoam;
uniform highp float envmapStrength;

varying highp vec2 texCoord;
varying highp vec3 viewRay;

highp vec3 getPos(highp vec3 eye_1, highp vec3 eyeLook_1, highp vec3 viewRay_1, highp float depth, highp vec2 cameraProj_1)
{
    highp float linearDepth = cameraProj_1.y / (((depth * 0.5) + 0.5) - cameraProj_1.x);
    highp float viewZDist = dot(eyeLook_1, viewRay_1);
    highp vec3 wposition = eye_1 + (viewRay_1 * (linearDepth / viewZDist));
    return wposition;
}

void main()
{
    highp float gdepth = (texture2DLodEXT(gbufferD, texCoord, 0.0).x * 2.0) - 1.0;
    if (gdepth == 1.0)
    {
        gl_FragData[0] = vec4(0.0);
        return;
    }
    if (eye.z < (-0.5))
    {
        gl_FragData[0] = vec4(0.0);
        return;
    }
    highp vec3 vray = normalize(viewRay);
    highp vec3 p = getPos(eye, eyeLook, vray, gdepth, cameraProj);
    highp float speed = (time * 2.0) * 1.0;
    p.z += (((sin(((p.x * 10.0) / 1.0) + speed) * cos(((p.y * 10.0) / 1.0) + speed)) / 50.0) * 1.0);
    if (p.z > (-0.5))
    {
        gl_FragData[0] = vec4(0.0);
        return;
    }
    highp vec3 v = normalize(eye - p);
    highp float t = (-(dot(eye, vec3(0.0, 0.0, 1.0)) - (-0.5))) / dot(v, vec3(0.0, 0.0, 1.0));
    highp vec3 hit = eye + (v * t);
    highp vec2 _149 = hit.xy * 1.0;
    hit = vec3(_149.x, _149.y, hit.z);
    hit.z += (-0.5);
    highp vec2 tcnor0 = hit.xy / vec2(3.0);
    highp vec3 n0 = texture2DLodEXT(sdetail, tcnor0 + vec2(speed / 60.0, speed / 120.0), 0.0).xyz;
    highp vec2 tcnor1 = (hit.xy / vec2(6.0)) + (n0.xy / vec2(20.0));
    highp vec3 n1 = texture2DLodEXT(sbase, tcnor1 + vec2(speed / 40.0, speed / 80.0), 0.0).xyz;
    highp vec3 n2 = normalize((((n1 + n0) / vec3(2.0)) * 2.0) - vec3(1.0));
    highp float ddepth = (texture2DLodEXT(gbufferD, texCoord + ((n2.xy * n2.z) / vec2(40.0)), 0.0).x * 2.0) - 1.0;
    highp vec3 p2 = getPos(eye, eyeLook, vray, ddepth, cameraProj);
    highp vec2 _239;
    if (p2.z > (-0.5))
    {
        _239 = texCoord;
    }
    else
    {
        _239 = texCoord + (((n2.xy * n2.z) / vec2(30.0)) * 1.0);
    }
    highp vec2 tc = _239;
    highp float fresnel = 1.0 - max(dot(n2, v), 0.0);
    fresnel = pow(fresnel, 30.0) * 0.449999988079071044921875;
    highp vec3 r = reflect(-v, n2);
    highp vec3 refracted = texture2DLodEXT(tex, tc, 0.0).xyz;
    highp vec3 _282 = mix(refracted, vec3(0.5), vec3(fresnel * 1.0));
    gl_FragData[0] = vec4(_282.x, _282.y, _282.z, gl_FragData[0].w);
    highp vec3 _290 = gl_FragData[0].xyz * vec3(0.60000002384185791015625, 0.769999980926513671875, 1.0);
    gl_FragData[0] = vec4(_290.x, _290.y, _290.z, gl_FragData[0].w);
    highp vec3 _308 = gl_FragData[0].xyz + vec3(clamp((pow(max(dot(r, ld), 0.0), 200.0) * 208.0) / 25.1327419281005859375, 0.0, 2.0));
    gl_FragData[0] = vec4(_308.x, _308.y, _308.z, gl_FragData[0].w);
    highp vec3 _322 = gl_FragData[0].xyz * (1.0 - clamp((-(p.z - (-0.5))) * 0.20000000298023223876953125, 0.0, 0.89999997615814208984375));
    gl_FragData[0] = vec4(_322.x, _322.y, _322.z, gl_FragData[0].w);
    gl_FragData[0].w = clamp(abs(p.z - (-0.5)) * 5.0, 0.0, 1.0);
    highp float fd = abs(p.z - (-0.5));
    if (fd < 0.100000001490116119384765625)
    {
        highp vec3 foamMask0 = texture2DLodEXT(sfoam, tcnor0 * 10.0, 0.0).xyz;
        highp vec3 foamMask1 = texture2DLodEXT(sfoam, tcnor1 * 11.0, 0.0).xyz;
        highp vec3 foam = (vec3(1.0) - foamMask0.xxx) - foamMask1.zzz;
        highp float fac = 1.0 - (fd * 10.0);
        highp vec3 _380 = mix(gl_FragData[0].xyz, clamp(foam, vec3(0.0), vec3(1.0)), vec3(clamp(fac, 0.0, 1.0)));
        gl_FragData[0] = vec4(_380.x, _380.y, _380.z, gl_FragData[0].w);
    }
}

